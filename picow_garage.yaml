substitutions: # https://esphome.io/guides/configuration-types.html#substitutions
  devicename: picow_garage
  friendlyname: PiCOW_Garage

  fallback_ssid: <<ap_ssid_name>>
  fallback_ssid_password: <<ap_ssid_password>>
  
  api_encryption_key: <<api_encryption>>
  ota_password: <<ota_password>>
  
  # Pulse the onboard LED light every XX milliseconds !! DO NOT PUT IT LOWER THAN 1000 !!
  status_led_pulse_time: "2000"

  # How long in milliseconds it takes for the garage door to open and close
  garage_door_open_time: "25000" 
  garage_door_close_time: "25000"

  # How long in milliseconds to hold open the relays for the open, close and stop commands.
  relay_open_hold_time: "2000"
  relay_close_hold_time: "2000"
  relay_stop_hold_time: "5000"



esphome:
  name: ${devicename}
  min_version: 2023.10.6
  on_boot:
    priority: -100.0 # https://esphome.io/components/esphome.html#on-boot
    then:
      if:
        condition:
         - binary_sensor.is_on: ${devicename}_control_box_stop # Check to see if the control box STOP is OFF
        then: #If it is then turn on the relay.
          - switch.turn_on: ${devicename}_relay_stop 
       
rp2040:
  board: rpipicow
  framework:
    # Required until https://github.com/platformio/platform-raspberrypi/pull/36 is merged
    platform_version: https://github.com/maxgerhardt/platform-raspberrypi.git

# Enable logging https://esphome.io/components/logger.html#
logger:
  level: DEBUG

# Enable Home Assistant API
api:
  encryption:
    key: ${api_encryption_key}

ota:
  password: ${ota_password}

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  fast_connect: true
  power_save_mode: none

  # Enable fallback hotspot in case wifi connection fails
  ap:
    ssid: ${fallback_ssid}
    password: ${fallback_ssid_password}

output:
  # Built-in LED
  - platform: gpio
    pin:
      number: 32  # 25 for Pico (non-W)
      mode: output
    id: ${devicename}_LED

# Pulse the onboard LED every x seconds, status light
interval: 
  - interval: ${status_led_pulse_time}ms
    then:
      - output.turn_on: ${devicename}_LED
      - delay: 100ms
      - output.turn_off: ${devicename}_LED


binary_sensor:

# https://esphome.io/components/binary_sensor/status.html
  - platform: status
    name: ${friendlyname} Power Status
    id: ${devicename}_power_status

###### START >> GARAGE DOOR OPEN/CLOSE CONTACT SENSOR(s) ######

  - platform: template
    name: ${friendlyname} Position
    id: ${devicename}_position
    device_class: garage_door
 
  - platform: template
    name: ${friendlyname} Status
    id: ${devicename}_status
    device_class: problem

# Door Open
  - platform: gpio
    pin:
      number: 5
      mode:
        input: true
        pullup: true
        output: false
        open_drain: false
        pulldown: false
      inverted: false
    id: ${devicename}_closed
    internal: True # Will not publish to Home Assistant
    publish_initial_state: True # Sensor will publish its initial state at boot
    on_state:
      - delay: ${garage_door_open_time}ms # The length of time it takes for the door to open
      - if:
          condition:
            and: #check to see if the closed sensor is off and and the open sensor is on (Garage Door Open)
             - binary_sensor.is_on: ${devicename}_open
             - binary_sensor.is_off: ${devicename}_closed
          then:
            - binary_sensor.template.publish:
                id: ${devicename}_status 
                state: OFF # There are no Errors, at least 1 sensor is ON, change the state to OFF (ALL IS OK)
            - binary_sensor.template.publish:
                id: ${devicename}_position
                state: ON # Turn ON the sensor with device class Garage door this means OPEN 
            # Remove the cover template publish (3 lines) below if not using ESP cover
            - cover.template.publish:
                id: ${devicename}_cover
                state: OPEN
      - if:
          condition:
            and: # Both senors are ON (the door is stuck between 2 sensors)
              - binary_sensor.is_on: ${devicename}_open
              - binary_sensor.is_on: ${devicename}_closed
          then:   
            - binary_sensor.template.publish:
                id: ${devicename}_status
                state: ON # The door is stuck between sensors, change the state to ON (PROBLEM DETECTED)


# Door Closed
  - platform: gpio
    pin:
      number: 6
      mode:
        input: true
        pullup: true
        output: false
        open_drain: false
        pulldown: false
      inverted: false
    id: ${devicename}_open
    internal: True # Will not publish to Home Assistant  
    publish_initial_state: True # sensor will publish its initial state at boot
    on_state:
      - delay: ${garage_door_close_time}ms # The length of time it takes for the door to close
      - if:
          condition:
            and: #check to see if the open sensor is off and and the closed sensor is on (Garage Door Closed)
             - binary_sensor.is_off: ${devicename}_open
             - binary_sensor.is_on: ${devicename}_closed
          then:
            - binary_sensor.template.publish:
                id: ${devicename}_status
                state: OFF # There are no Errors, at least 1 sensor is ON, change the state to OFF (ALL IS OK)
            - binary_sensor.template.publish:
                id: ${devicename}_position
                state: OFF # Turn OFF the sensor with device class Garage door this means CLOSED 
            # Remove the cover template publish (3 lines) below if not using ESP cover
            - cover.template.publish:
                id: ${devicename}_cover
                state: CLOSED
      - if:
          condition:
            and: # Both senors are ON (the door is stuck between 2 sensors)
            - binary_sensor.is_on: ${devicename}_open
            - binary_sensor.is_on: ${devicename}_closed
          then:   
            - binary_sensor.template.publish:
               id: ${devicename}_status
               state: ON # The door is stuck between sensors, change the state to ON (PROBLEM DETECTED)

###### END >> GARAGE DOOR OPEN/CLOSE CONTACT SENSOR(s) ######


###### START >> EXTERNAL CONTROL BOX INPUTS ######

# GPI for remote button press to OPEN garage door
  - platform: gpio
    pin:
      number: 8
      mode:
        input: true
        pullup: true
      inverted: true #https://esphome.io/components/binary_sensor/gpio.html#inverting-values
    name: ${friendlyname} Control Box Open
    id: ${devicename}_control_box_open
    on_press:
      if: # I would like the relay switch to be enabled before sending the OPEN command
        condition:
          - binary_sensor.is_on: ${devicename}_control_box_enabled
        then:
          - switch.turn_off: ${devicename}_relay_close
          - switch.turn_on: ${devicename}_relay_open

 # GPI for remote button press to CLOSE garage door
  - platform: gpio
    pin:
      number: 9
      mode:
        input: true
        pullup: true
      inverted: true #https://esphome.io/components/binary_sensor/gpio.html#inverting-values
    name: ${friendlyname} Control Box Close
    id: ${devicename}_control_box_close
    on_press:
      if: # I would like the relay switch to be enabled before sending the CLOSE command
        condition:
          - binary_sensor.is_on: ${devicename}_control_box_enabled
        then:
          - switch.turn_off: ${devicename}_relay_open
          - switch.turn_on: ${devicename}_relay_close

# GPI for remote button press to STOP garage door
  - platform: gpio
    pin:
      number: 10
      mode:
        input: true
        pullup: true
      inverted: true #https://esphome.io/components/binary_sensor/gpio.html#inverting-values
    name: ${friendlyname} Control Box Stop
    id: ${devicename}_control_box_stop
    on_press:
      - switch.turn_on: ${devicename}_relay_stop
      - logger.log: "${friendlyname} CONTROL BOX STOP PRESSED !!"
    on_release:
        - logger.log: "${friendlyname} CONTROL BOX STOP RELEASED !!"
      # ^^ Notice there are no conditions, if I press STOP.. I want it to trigger the STOP Command.

# GPI for remote switch to ENABLE garage door external control box
# Also used for resetting the PiCOW, if pattern is matched
  - platform: gpio
    pin:
      number: 11
      mode:
        input: true
        pullup: true
      inverted: true #https://esphome.io/components/binary_sensor/gpio.html#inverting-values
    name: ${friendlyname} Control Box Enabled
    id: ${devicename}_control_box_enabled
    on_multi_click: # https://esphome.io/components/binary_sensor/index.html#on-multi-click
    - timing:
          - OFF for at most 2000ms # Enable button should be OFF for under XXXX ms
          - ON for at least 500ms # Enable button should be ON for over XXXms
      then:
        - logger.log: Control Box Reset ${devicename}
        - delay: 1000ms
        - button.press: ${devicename}_restart

###### END >> EXTERNAL BOX INPUTS ######


switch:
###### START >> OUTPUTS TO GARAGE DOOR RELAY ######
  
  - platform: template
    name: ${friendlyname} Open
    icon: "mdi:arrow-up-bold"
    id: ${devicename}_relay_open
    lambda: |-
      if (id(${devicename}_relay_open_internal).state) {
        return true;
      } else {
        return false;
      }
    turn_on_action:
      if:
        condition:
          - binary_sensor.is_off: ${devicename}_control_box_stop # Check to make sure the control box STOP is OFF
        then:
          - switch.turn_off: ${devicename}_relay_close_internal
          - switch.turn_off: ${devicename}_relay_stop_internal
          - delay: 50ms
          - switch.turn_on: ${devicename}_relay_open_internal
          - delay: ${relay_open_hold_time} ms # Hold the relay for XX ms
          - switch.turn_off: ${devicename}_relay_open_internal
        else:
          - logger.log: "CANCEL OPEN - ${friendlyname} Control Box STOP ACTIVE !!"
    turn_off_action:
      - switch.turn_off: ${devicename}_relay_open_internal


  - platform: template
    name: ${friendlyname} Close
    icon: "mdi:arrow-down-bold"
    id: ${devicename}_relay_close
    lambda: |-
      if (id(${devicename}_relay_close_internal).state) {
        return true;
      } else {
        return false;
      }
    turn_on_action:
      if:
        condition:
          - binary_sensor.is_off: ${devicename}_control_box_stop # Check to make sure the control box STOP is OFF
        then: 
          - switch.turn_off: ${devicename}_relay_open_internal
          - switch.turn_off: ${devicename}_relay_stop_internal
          - delay: 50ms
          - switch.turn_on: ${devicename}_relay_close_internal
          - delay: ${relay_close_hold_time} ms # Hold the relay for XX ms
          - switch.turn_off: ${devicename}_relay_close_internal
        else:
          - logger.log: "CANCEL CLOSE - ${friendlyname} Control Box STOP ACTIVE !!"
    turn_off_action:
      - switch.turn_off: ${devicename}_relay_close_internal


  - platform: template
    name: ${friendlyname} Stop
    icon: "mdi:stop"
    id: ${devicename}_relay_stop
    lambda: |-
      if (id(${devicename}_relay_stop_internal).state) {
        return true;
      } else {
        return false;
      }
    turn_on_action:
      - switch.turn_off: ${devicename}_relay_open_internal
      - switch.turn_off: ${devicename}_relay_close_internal
      - delay: 50ms
      - switch.turn_on: ${devicename}_relay_stop_internal
      - delay: ${relay_stop_hold_time} ms # Hold the relay for XX ms
      - while: # Going to LOOP This until the stop button is released
          condition:
            - binary_sensor.is_on: ${devicename}_control_box_stop
          then:
            - logger.log: "${friendlyname} Control Box STOP STILL ACTIVE !! - Looping"
            - delay: 5s
      - switch.turn_off: ${devicename}_relay_stop_internal
    turn_off_action:
      if:
        condition:
          - binary_sensor.is_off: ${devicename}_control_box_stop # Check to make sure the control box STOP is OFF
        then:
          - switch.turn_off: ${devicename}_relay_stop_internal
        else:
          - logger.log: "${friendlyname} Control Box STOP ACTIVE Cancelling Turn OFF Request!!"


  # RELAY OPEN
  - platform: gpio
    id: ${devicename}_relay_open_internal
    internal: true
    pin:
      number: 0
      inverted: true
      mode:
        input: false
        pullup: false
        output: true
        open_drain: false
    
  
  # RELAY CLOSE
  - platform: gpio
    id: ${devicename}_relay_close_internal
    internal: true
    pin:
      number: 1
      inverted: true
      mode: 
        input: false
        pullup: false
        output: true
        open_drain: false

  
  # RELAY STOP
  - platform: gpio
    id: ${devicename}_relay_stop_internal
    internal: true
    pin:
      number: 2
      inverted: true
      mode:
        input: false
        pullup: false
        output: true
        open_drain: false

###### END >> OUTPUTS TO GARAGE DOOR RELAY ######

#Temprature Sensor
dallas:
    - pin:
        number: 17 # Monitor Pin on the Pico W for the sensor(s)

sensor:

  # https://esphome.io/components/sensor/dallas.html
  - platform: dallas
    address: 0x560621302c840b28 # Sensor Address
    name: ${friendlyname} Outdoor Temperature # Name of the Sensor
    id: ${devicename}_dallas_outdoor_temperature

  - platform: dallas
    address: 0x623ce60457dbca28 # Sensor Address
    name: ${friendlyname} Case Temperature # Name of the Sensor
    id: ${devicename}_dallas_case_temperature
  
  # https://esphome.io/components/sensor/internal_temperature.html
  - platform: internal_temperature
    name: ${friendlyname} Temperature
    id: ${devicename}_temperature

  - platform: wifi_signal # Report the WiFi signal strength/RSSI in dB
    name: ${friendlyname} WiFi Signal (dB)
    id: ${devicename}_wifi_signal_db
    update_interval: 60s
    icon: mdi:wifi
    entity_category: "diagnostic"

  - platform: copy # Report the WiFi signal strength in %
    source_id: ${devicename}_wifi_signal_db
    name: ${friendlyname} WiFi Signal (%)
    id: ${devicename}_wifi_signal_percentage
    filters:
      - lambda: return min(max(2 * (x + 100.0), 0.0), 100.0);
    unit_of_measurement: " %"
    icon: mdi:wifi
    entity_category: "diagnostic"

  - platform: uptime # Uptime of the PicoW
    update_interval: 5s
    id: ${devicename}_uptime_s

# Convert the Uptime to Days Hours Minutes Seconds
# first duration is to get around an issue on startup
# where uptime shows it has been on line for 136 years
text_sensor: 
  - platform: template
    name: ${friendlyname} Uptime
    icon: mdi:clock-start
    update_interval: 60s
    lambda: |-
      uint32_t dur = id(${devicename}_uptime_s).state;
      int dys = 0;
      int hrs = 0;
      int mnts = 0;
      if (dur > 4294944000) {
        dys = 0;
        hrs = 0;
        mnts = 0;
        dur = 0;
      }
      if (dur > 86399) {
        dys = trunc(dur / 86400);
        dur = dur - (dys * 86400);
      }
      if (dur > 3599) {
        hrs = trunc(dur / 3600);
        dur = dur - (hrs * 3600);
      }
      if (dur > 59) {
        mnts = trunc(dur / 60);
        dur = dur - (mnts * 60);
      }
      char buffer[17];
      sprintf(buffer, "%02ud %02uh %02um %02us", dys, hrs, mnts, dur);
      return {buffer};

  - platform: wifi_info
    ip_address:
      name: ${friendlyname} IP Address
      update_interval: 3600s
      id: ${devicename}_ip_address
    ssid:
      name: ${friendlyname} SSID
      id: ${devicename}_ssid_connection
    mac_address:
      name: ${friendlyname} MAC Address
      id: ${devicename}_mac_address

# Restart button
button:
  - platform: restart
    name: ${friendlyname} Restart
    id: ${devicename}_restart
    icon: "mdi:power"
    on_press:
      then:
      - logger.log: "${devicename} Restarting !!"

# Home Assistant Cover
cover:
  - platform: template
    device_class: garage
    id: ${devicename}_cover
    name: ${friendlyname}
    open_action:
      - switch.turn_on: ${devicename}_relay_open
    close_action:
      - switch.turn_on: ${devicename}_relay_close
    stop_action:
      - switch.turn_on: ${devicename}_relay_stop
