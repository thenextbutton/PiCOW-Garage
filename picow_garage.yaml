substitutions: # https://esphome.io/guides/configuration-types.html#substitutions
  devicename: picow_garage
  friendlyname: Pi COW

  fallback_ssid: <<ap_ssid_name>>
  fallback_ssid_password: <<ap_ssid_password>>
  
  api_encryption_key: <<api_encryption>>
  ota_password: <<ota_password>>
  
  # Pulse the onboard LED light every XX milliseconds !! DO NOT PUT IT LOWER THAN 1000 !!
  status_led_pulse_time: "2000"

  # How long, in millieseconds, to wait before closing the garage door (when using the control box)
  # This allows a user to exit via the garage door before the door is requested to be closed.
  # If needing instant closure, set this to 0
  control_box_close_wait_time: "30000"   

  # How long, in milliseconds, it takes for the garage door to open and close, this will act as a timeout.
  garage_door_time: "20000" 
  garage_door_debounce_time: "500" # https://esphome.io/components/binary_sensor/gpio.html#debouncing-values

  # How long, in milliseconds, to hold the contact for the open, close and stop commands.
  contact_open_hold_time: "500"
  contact_close_hold_time: "500"
  contact_stop_hold_time: "5000"
  contact_debounce_time: "10" # https://esphome.io/components/binary_sensor/gpio.html#debouncing-values

  # Car Presence Sensor, HC-SR04 ultrasonic sensor
  car_presence_detect_distance: "0.50" # distance is in meters to assume car is present ("HOME"), i.e. 0.50 is 50cm, 1.00 is 1meter
  car_presence_detect_time: "30000" # time in seconds to "ping" to see if an object is present.

  # Dallas Temperature Sensor  https://esphome.io/components/sensor/dallas_temp.html
  dallas_outdoor_temperature_sensor_address: "0x560621302c840b28"
  dallas_outdoor_temperature_update_interval: "120"
  dallas_case_temperature_sensor_address: "0x623ce60457dbca28"
  dallas_case_temperature_update_interval: "120"


esphome:
  name: ${devicename}
    min_version: 2024.12.4 # https://esphome.io/components/esphome.html#minimum-esphome-version
  on_boot: # https://esphome.io/components/esphome.html#on-boot
    priority: -100.0
    then:
      # Check to see if the control box STOP is ON
      if:
        condition:
          - binary_sensor.is_on: ${devicename}_control_box_stop 
        then: 
            #If it is then turn on the contact.
          - switch.turn_on: ${devicename}_contact_stop 
       
rp2040:
  board: rpipicow
  framework:
    # Required until https://github.com/platformio/platform-raspberrypi/pull/36 is merged
    platform_version: https://github.com/maxgerhardt/platform-raspberrypi.git

# Enable logging https://esphome.io/components/logger.html#
logger:
  level: DEBUG

# Enable Home Assistant API
api:
  encryption:
    key: ${api_encryption_key}

ota:
- platform: esphome
  password: ${ota_password}

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  fast_connect: true
  power_save_mode: none

  # Enable fallback hotspot in case wifi connection fails
ap:
  ssid: ${fallback_ssid}
  password: ${fallback_ssid_password}

output:
  # Built-in LED
  - platform: gpio
    pin:
      number: 32  # 25 for Pico (non-W)
      mode: output
    id: ${devicename}_LED

# Pulse the onboard LED every x seconds, status light
interval: 
  - interval: ${status_led_pulse_time}ms
    then:
      - output.turn_on: ${devicename}_LED
      - delay: 100ms
      - output.turn_off: ${devicename}_LED


binary_sensor:

# https://esphome.io/components/binary_sensor/status.html
  - platform: status
    name: ${friendlyname} Power Status
    id: ${devicename}_power_status

  - platform: template
    name: ${friendlyname} Car Presence
    device_class: presence
    id: ${devicename}_car_presence_status
    icon: "mdi:car"
    lambda: |-
      if (id(${devicename}_car_presence_distance).state < ${car_presence_detect_distance}) {
            return true;
      } else {
            return false;
      } 

###### START >> GARAGE DOOR OPEN/CLOSE CONTACT SENSOR(s) ######

  - platform: template
    name: ${friendlyname} Position
    id: ${devicename}_position
    device_class: garage_door
 
  - platform: template
    name: ${friendlyname} Status
    id: ${devicename}_status
    device_class: problem

# Door OPEN
  - platform: gpio
    pin:
      number: 5
      mode:
        input: true
        pullup: true
        output: false
        open_drain: false
        pulldown: false
      inverted: true
    id: ${devicename}_open
    internal: True # Will not publish to Home Assistant
    publish_initial_state: True # Sensor will publish its initial state at boot
    filters:
      - delayed_on: ${garage_door_debounce_time} ms # https://esphome.io/components/binary_sensor/gpio.html#debouncing-values
    on_state:
      - logger.log: "OPEN contact state change detected"
      - wait_until:
          condition:
            binary_sensor.is_on: ${devicename}_closed
          timeout: ${garage_door_time} ms # The length of time it takes for the door to open
      - logger.log: "Running Status Script"
      - script.execute: ${devicename}_garage_door_status_script
      
# Door CLOSED
  - platform: gpio
    pin:
      number: 6
      mode:
        input: true
        pullup: true
        output: false
        open_drain: false
        pulldown: false
      inverted: true
    id: ${devicename}_closed
    internal: True # Will not publish to Home Assistant  
    publish_initial_state: True # sensor will publish its initial state at boot
    filters:
      - delayed_on: ${garage_door_debounce_time} ms # https://esphome.io/components/binary_sensor/gpio.html#debouncing-values
    on_state:
      - logger.log: "CLOSED contact state change detected"
      - wait_until:
          condition:
            binary_sensor.is_on: ${devicename}_open
          timeout: ${garage_door_time} ms # The length of time it takes for the door to open
      - logger.log: "Running Status Script"
      - script.execute: ${devicename}_garage_door_status_script

###### END >> GARAGE DOOR OPEN/CLOSE CONTACT SENSOR(s) ######


###### START >> EXTERNAL CONTROL BOX INPUTS ######

# GPI for remote button press to OPEN garage door
  - platform: gpio
    pin:
      number: 8
      mode:
        input: true
        pullup: true
      inverted: true #https://esphome.io/components/binary_sensor/gpio.html#inverting-values
    name: ${friendlyname} Control Box Open
    id: ${devicename}_control_box_open
    filters:
      - delayed_on: ${contact_debounce_time} ms # https://esphome.io/components/binary_sensor/gpio.html#debouncing-values
    on_press:
      if: # I would like the enable switch to be ON before sending the OPEN command
        condition:
          - binary_sensor.is_on: ${devicename}_control_box_enabled
        then:
          - switch.turn_off: ${devicename}_contact_close
          - switch.turn_on: ${devicename}_contact_open

 # GPI for remote button press to CLOSE garage door
  - platform: gpio
    pin:
      number: 9
      mode:
        input: true
        pullup: true
      inverted: true #https://esphome.io/components/binary_sensor/gpio.html#inverting-values
    name: ${friendlyname} Control Box Close
    id: ${devicename}_control_box_close
    filters:
      - delayed_on: ${contact_debounce_time} ms # https://esphome.io/components/binary_sensor/gpio.html#debouncing-values
    on_press:
      if: # I would like the enable switch to be ON before sending the OPEN command
        condition:
          - binary_sensor.is_on: ${devicename}_control_box_enabled
        then:
          - delay: ${control_box_close_wait_time} ms # Put a pause here to allow person to leave the garage
          - switch.turn_off: ${devicename}_contact_open
          - switch.turn_on: ${devicename}_contact_close

# GPI for remote button press to STOP garage door
  - platform: gpio
    pin:
      number: 10
      mode:
        input: true
        pullup: true
      inverted: true # https://esphome.io/components/binary_sensor/gpio.html#inverting-values
    name: ${friendlyname} Control Box Stop
    id: ${devicename}_control_box_stop
    filters:
      - delayed_on: 10ms # https://esphome.io/components/binary_sensor/gpio.html#debouncing-values
    on_press:
      - switch.turn_on: ${devicename}_contact_stop
      - logger.log: "${friendlyname} CONTROL BOX STOP PRESSED !!"
    on_release:
        - logger.log: "${friendlyname} CONTROL BOX STOP RELEASED !!"
      # ^^ Notice there are no conditions, if I press STOP.. I want it to trigger the STOP Command.

# GPI for remote switch to ENABLE garage door external control box
# Also used for resetting the PiCOW, if pattern is matched
  - platform: gpio
    pin:
      number: 11
      mode:
        input: true
        pullup: true
      inverted: true # https://esphome.io/components/binary_sensor/gpio.html#inverting-values
    name: ${friendlyname} Control Box Enabled
    id: ${devicename}_control_box_enabled
    filters:
      - delayed_on: 10ms # https://esphome.io/components/binary_sensor/gpio.html#debouncing-values
    on_multi_click: # https://esphome.io/components/binary_sensor/index.html#on-multi-click
    - timing:
          - OFF for at most 2000ms # Enable button should be OFF for under XXXX ms
          - ON for at least 500ms # Enable button should be ON for over XXXms
      then:
        - logger.log: Control Box Reset ${devicename}
        - delay: 1000ms
        - button.press: ${devicename}_restart

###### END >> EXTERNAL BOX INPUTS ######


switch:
###### START >> OUTPUTS TO GARAGE DOOR contact ######
  
  - platform: template
    name: ${friendlyname} Open
    icon: "mdi:arrow-up-bold"
    id: ${devicename}_contact_open
    lambda: |-
      if (id(${devicename}_contact_open_internal).state) {
        return true;
      } else {
        return false;
      }
    turn_on_action:
      if:
        condition:
          - binary_sensor.is_off: ${devicename}_control_box_stop # Check to make sure the control box STOP is OFF
        then:
          - switch.turn_off: ${devicename}_contact_close_internal
          - switch.turn_off: ${devicename}_contact_stop_internal
          - delay: 50ms
          - switch.turn_on: ${devicename}_contact_open_internal
          - delay: ${contact_open_hold_time} ms # Hold the contact for XX ms
          - switch.turn_off: ${devicename}_contact_open_internal
        else:
          - logger.log: "CANCEL OPEN - ${friendlyname} Control Box STOP ACTIVE !!"
    turn_off_action:
      - switch.turn_off: ${devicename}_contact_open_internal


  - platform: template
    name: ${friendlyname} Close
    icon: "mdi:arrow-down-bold"
    id: ${devicename}_contact_close
    lambda: |-
      if (id(${devicename}_contact_close_internal).state) {
        return true;
      } else {
        return false;
      }
    turn_on_action:
      if:
        condition:
          - binary_sensor.is_off: ${devicename}_control_box_stop # Check to make sure the control box STOP is OFF
        then: 
          - switch.turn_off: ${devicename}_contact_open_internal
          - switch.turn_off: ${devicename}_contact_stop_internal
          - delay: 50ms
          - switch.turn_on: ${devicename}_contact_close_internal
          - delay: ${contact_close_hold_time} ms # Hold the contact for XX ms
          - switch.turn_off: ${devicename}_contact_close_internal
        else:
          - logger.log: "CANCEL CLOSE - ${friendlyname} Control Box STOP ACTIVE !!"
    turn_off_action:
      - switch.turn_off: ${devicename}_contact_close_internal


  - platform: template
    name: ${friendlyname} Stop
    icon: "mdi:stop"
    id: ${devicename}_contact_stop
    lambda: |-
      if (id(${devicename}_contact_stop_internal).state) {
        return true;
      } else {
        return false;
      }
    turn_on_action:
      - switch.turn_off: ${devicename}_contact_open_internal
      - switch.turn_off: ${devicename}_contact_close_internal
      - delay: 50ms
      - switch.turn_on: ${devicename}_contact_stop_internal
      - delay: ${contact_stop_hold_time} ms # Hold the contact for XX ms
      - while: # Going to LOOP this until the stop button is released
          condition:
            - binary_sensor.is_on: ${devicename}_control_box_stop
          then:
            - logger.log: "${friendlyname} Control Box STOP STILL ACTIVE !! - Looping"
            - delay: 5s
      - switch.turn_off: ${devicename}_contact_stop_internal
    turn_off_action:
      if:
        condition:
          - binary_sensor.is_off: ${devicename}_control_box_stop # Check to make sure the control box STOP is OFF
        then:
          - switch.turn_off: ${devicename}_contact_stop_internal
        else:
          - logger.log: "${friendlyname} Control Box STOP ACTIVE Cancelling Turn OFF Request!!"


  # Contact OPEN
  - platform: gpio
    id: ${devicename}_contact_open_internal
    internal: true
    pin:
      number: 0
      inverted: true
      mode:
        input: false
        pullup: false
        output: true
        open_drain: false
    
  
  # Contact CLOSE
  - platform: gpio
    id: ${devicename}_contact_close_internal
    internal: true
    pin:
      number: 1
      inverted: true
      mode: 
        input: false
        pullup: false
        output: true
        open_drain: false

  
  # Contact STOP
  - platform: gpio
    id: ${devicename}_contact_stop_internal
    internal: true
    pin:
      number: 2
      inverted: true
      mode:
        input: false
        pullup: false
        output: true
        open_drain: false

###### END >> OUTPUTS TO GARAGE DOOR contact ######

#Temprature Sensor
# https://esphome.io/components/one_wire.html
one_wire:
  - platform: gpio
    pin: GPIO17
    
sensor:

 # https://esphome.io/components/sensor/ultrasonic.html
  - platform: ultrasonic
    trigger_pin: 28
    echo_pin: 27
    name: ${friendlyname} Car Presence Distance Sensor
    id: ${devicename}_car_presence_distance
    update_interval: ${car_presence_detect_time} ms
    unit_of_measurement: "m"
    accuracy_decimals: 2
    icon: "mdi:arrow-expand-horizontal"
    internal: true # Comment this out in order to display stats in Home Assistant

  # https://esphome.io/components/sensor/dallas_temp.html
  - platform: dallas_temp
    address: ${dallas_outdoor_temperature_sensor_address} # Sensor Address
    name: ${friendlyname} Outdoor Temperature # Name of the Sensor
    id: ${devicename}_dallas_outdoor_temperature
    update_interval: ${dallas_outdoor_temperature_update_interval}s

  - platform: dallas_temp
    address: ${dallas_case_temperature_sensor_address} # Sensor Address
    name: ${friendlyname} Case Temperature # Name of the Sensor
    id: ${devicename}_dallas_case_temperature
    update_interval: ${dallas_case_temperature_update_interval}s
  
  # https://esphome.io/components/sensor/internal_temperature.html
  - platform: internal_temperature
    name: ${friendlyname} Temperature
    id: ${devicename}_temperature

  - platform: wifi_signal # Report the WiFi signal strength/RSSI in dB
    name: ${friendlyname} WiFi Signal (dB)
    id: ${devicename}_wifi_signal_db
    update_interval: 60s
    icon: mdi:wifi
    entity_category: "diagnostic"

  - platform: copy # Report the WiFi signal strength in %
    source_id: ${devicename}_wifi_signal_db
    name: ${friendlyname} WiFi Signal (%)
    id: ${devicename}_wifi_signal_percentage
    filters:
      - lambda: return min(max(2 * (x + 100.0), 0.0), 100.0);
    unit_of_measurement: " %"
    icon: mdi:wifi
    entity_category: "diagnostic"

  - platform: uptime # Uptime of the PicoW
    update_interval: 5s
    id: ${devicename}_uptime_s
      
# Convert the Uptime to Days Hours Minutes Seconds
# first duration is to get around an issue on startup
# where uptime shows it has been on line for 136 years
text_sensor: 
  - platform: template
    name: ${friendlyname} Uptime
    icon: mdi:clock-start
    update_interval: 60s
    lambda: |-
      uint32_t dur = id(${devicename}_uptime_s).state;
      int dys = 0;
      int hrs = 0;
      int mnts = 0;
      if (dur > 4294944000) {
        dys = 0;
        hrs = 0;
        mnts = 0;
        dur = 0;
      }
      if (dur > 86399) {
        dys = trunc(dur / 86400);
        dur = dur - (dys * 86400);
      }
      if (dur > 3599) {
        hrs = trunc(dur / 3600);
        dur = dur - (hrs * 3600);
      }
      if (dur > 59) {
        mnts = trunc(dur / 60);
        dur = dur - (mnts * 60);
      }
      char buffer[17];
      sprintf(buffer, "%02ud %02uh %02um %02us", dys, hrs, mnts, dur);
      return {buffer};

  - platform: wifi_info
    ip_address:
      name: ${friendlyname} IP Address
      update_interval: 3600s
      id: ${devicename}_ip_address
      icon: "mdi:ip-network"
    ssid:
      name: ${friendlyname} SSID
      id: ${devicename}_ssid_connection
      icon: "mdi:wifi"
    mac_address:
      name: ${friendlyname} MAC Address
      id: ${devicename}_mac_address
      icon: "mdi:network"

# Restart button
button:
  - platform: restart
    name: ${friendlyname} Restart
    id: ${devicename}_restart
    icon: "mdi:power"
    on_press:
      then:
      - logger.log: "${devicename} Restarting !!"

# Home Assistant Cover
cover:
  - platform: template
    device_class: garage
    id: ${devicename}_cover
    name: ${friendlyname}
    open_action:
      - switch.turn_on: ${devicename}_contact_open
    close_action:
      - switch.turn_on: ${devicename}_contact_close
    stop_action:
      - switch.turn_on: ${devicename}_contact_stop


###### START >> Garage Door position logic ######
script: # https://esphome.io/guides/automations.html#script-component
  - id: ${devicename}_garage_door_status_script
    mode: single
    then:
      - if:
          condition:
            and: # Check to see if the open sensor is OFF and and the closed sensor is ON (Garage Door Closed)
             - binary_sensor.is_off: ${devicename}_open
             - binary_sensor.is_on: ${devicename}_closed
          then:
            - binary_sensor.template.publish:
                id: ${devicename}_status
                state: OFF # There are no Errors, at least 1 sensor is ON, change the state to OFF (ALL IS OK)
            - binary_sensor.template.publish:
                id: ${devicename}_position
                state: OFF # Turn OFF the sensor with device class Garage door this means CLOSED 
            # Remove the cover template publish (3 lines) below if not using ESP cover
            - cover.template.publish:
                id: ${devicename}_cover
                state: CLOSED
      - if:
          condition:
            and: # Check to see if the open sensor is ON and and the closed sensor is OFF (Garage Door Closed)
             - binary_sensor.is_on: ${devicename}_open
             - binary_sensor.is_off: ${devicename}_closed
          then:
            - binary_sensor.template.publish:
                id: ${devicename}_status
                state: OFF # There are no Errors, at least 1 sensor is ON, change the state to OFF (ALL IS OK)
            - binary_sensor.template.publish:
                id: ${devicename}_position
                state: ON # Turn ON the sensor with device class Garage door this means OPEN
            # Remove the cover template publish (3 lines) below if not using ESP cover
            - cover.template.publish:
                id: ${devicename}_cover
                state: OPEN
      - if:
          condition:
            and: # The sensors are not in a valid state.
                - binary_sensor.is_on: ${devicename}_open
                - binary_sensor.is_on: ${devicename}_closed
          then:   
            - binary_sensor.template.publish:
               id: ${devicename}_status
               state: ON # Change the state to ON (PROBLEM DETECTED)
      - if:
          condition:
            and: # The sensors are not in a valid state.
                - binary_sensor.is_off: ${devicename}_open
                - binary_sensor.is_off: ${devicename}_closed
          then:   
            - binary_sensor.template.publish:
               id: ${devicename}_status
               state: ON # Change the state to ON (PROBLEM DETECTED)

###### END >> Garage Door position logic ######
